@[TOC](回溯法)

# 定义

> 在程序设计中，有相当一类求一组解，或求全部解或求最优解的问题，例如读者熟悉的八皇后问题，不是根据某种特定的计算法则，而是利用试探和回溯的搜索技术求解。回溯法也是设计递归过程的一种重要方法，它的求解过程实质上是一个先序遍历一棵"状态树"的过程,只是这棵树不是遍历前预先建立的,而是隐含在遍历过程中。
>
> *---*《数据结构》(严蔚敏)

怎么理解这段话呢？

首先，某种问题的解我们很难去找规律计算出来，没有公式可循，只能列出所有可能的解，然后一个个检查每个解是否符合我们要找的条件，也就是通常说的遍历。而解空间很多是树型的，就是树的遍历。

其次，树的先序遍历，也就是根是先被检查的，二叉树的先序遍历是根，左子树，右子树的顺序被输出。如果把树看做一种特殊的图的话，DFS就是先序遍历。所以，回溯和DFS是联系非常紧密的，可以认为回溯是DFS的一种应用场景。另外，DFS有个好处，它只存储深度，不存储广度。所以空间复杂度较小，而时间复杂度较大。

最后，某些解空间是非常大的，可以认为是一个非常庞大的树，此时完全遍历的时间复杂度是难以忍受的。此时可以在遍历的同时检查一些条件，当遍历某分支的时候，若发现条件不满足，则退回到根节点进入下一个分支的遍历。这就是“回溯”这个词的来源。而根据条件有选择的遍历，叫做剪枝或分枝定界。

> https://blog.csdn.net/qq_37763204/article/details/79519671　
>
> 1.回溯算法就是一种有组织的系统最优化搜索技术，可以看作蛮力法穷举搜索的改进。回溯法常常可以避免搜索所有可能的解，所以它适用于求解组织数量较大的问题。
>
> 　　2.首先我们先了解一下一个基本概念“解空间树”：问题的解空间一般使用解空间树的方式来组织，树的根节点位于第1层，表示搜索的初始状态，依次向下排列。
>
> 　　3.解空间树的动态搜索：在搜索至树中任一节点时，先判断该节点对应的部分是否是满足约束条件，或者是否超出目标函数的界，也就是判断该节点是否包含问题的最优解。如果肯定不包含，则跳过对该节点为根的子树的搜索，即所谓的**剪枝**；否则，进入该节点为根的子树，继续按照深度优先策略搜索。（这也是为什么回溯可以避免搜索所有的解）
>
> 　　4.在搜索过程中，通常采用两种策略避免无效搜索：
>
>    		（1）用约束条件剪除得不到的可行解的子树
>
> 　　　（2）用目标函数剪取得不到的最优解的子树
>
> 　　  （这两种方式统称为：剪枝函数）
>
> 　　5.在用回溯法求解问题时，常常遇到两种典型的解空间树：
>
> 　　**（1）子集树：但所有的问题是从n个元素的集合中找出满足某种性质的子集时，相应的解空间树成为子集树**
>
> 　　**（2）排列树：当所给出问题是确定n个元素满足某种性质的排列时，相应的解空间称为排列树。**     
>
> ​                                   
>
> 　　6.回溯法的一般步骤：
>
> 　　（1）设置初始化的方案（给变量赋初始值，读入已知数据等）
>
> 　　（2）变换方式去试探，若全部试完侧转（7）
>
> 　　（3）判断此法是否成功（通过约束函数），不成功则转（2）
>
> 　　（4）试探成功则前进一步再试探
>
> 　　（5）正确方案还是未找到则转（2）
>
> 　　（6）以找到一种方案则记录并打印
>
> 　　（7）退回一步（回溯），若未退到头则转（2）
>
> 　　（8）已退到头则结束或打印无解
>
>   7.回溯法的优点在于其结构明确，可读性强，易于理解，而且通过对问题的分析可以大大提高运行效率。

## 个人理解

回溯法相当于，相当于在递归算法的基础上，增加判定条件，不用在最后一层返回，同时，在递归的顶层一定是有一个循环来进行第一层的遍历

## 景点例题

- n皇后问题

  ```#c
  /*
   * @Descripttion: 
   * @version: 
   * @Author: LiuXin
   * @Contact: xinliu1996@163.com
   * @LastEditors: LiuXin
   * @LastEditTime: 2020-09-28 22:36:27
   * @FilePath: /LeetCodeNote/nQueens.cpp
   */
  
  #include <iostream>
  #include<string.h>
  #include<math.h>
  #include <bits/stdc++.h> 
  using namespace std;
  
  
  class NQueens{
      public:
      vector<int>x;//当前解
      int N;//
      int sum=0;
      int totalNQueens(int n){
          N=n;
          x=vector<int>(n+1);
          backTrace(1);
          return sum;
      }
      bool place(int col){  //col表示行，x[col]表示在第col行上的第col列放的位置。(col,x[col])用来描述放的点的位置
          for(int i =1;i<col;i++){
              if(abs(col-i)==abs(x[col]-x[i])||x[col]==x[i]){//abs(col-i)==abs(x[col]-x[i]])表示
                  return false;
              }
          }
          return true;
      }
  
      void backTrace(int t){
          if(t>N){
              sum++;
          }else{
              for(int j=1;j<=N;j++){//开始从第一行遍历，通过了就继续遍历
                  x[t]=j;
                  if(place(t)){
                      backTrace(t+1);
                  }
              }
          }
      }
      
  };
  
  int main(){
      NQueens *q=new NQueens();
      cout<<q->totalNQueens(8)<<endl;
  }
  ```
- 其余问题

  

